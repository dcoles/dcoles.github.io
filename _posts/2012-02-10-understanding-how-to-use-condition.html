---
layout: post
title: Understanding Condition Variables
date: '2012-02-10T00:29:00.000-08:00'
author: David Coles
tags: 
modified_time: '2012-02-10T00:32:57.602-08:00'
blogger_id: tag:blogger.com,1999:blog-4144304653010663466.post-3387130460081196001
blogger_orig_url: https://blog.dcoles.net/2012/02/understanding-how-to-use-condition.html
---

One concept that I often end up explaining a several times is POSIX Condition Variables. Taken straight from the&nbsp;official&nbsp;<a href="http://pubs.opengroup.org/onlinepubs/9699919799/">POSIX.1-2008/SUSv4</a>&nbsp;documentation:<br /><br /><a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_107"><b>Condition Variable</b></a><br /><blockquote class="tr_bq"><i>A synchronization object which allows a thread to suspend execution, repeatedly, until some associated predicate becomes true. A thread whose execution is suspended on a condition variable is said to be blocked on the condition variable.</i></blockquote>&nbsp;So clearly it's related to multi-threading but what do we use it for?<br /><br />Well if you've looked into multi-threaded programming you've&nbsp;probably&nbsp;encountered the concept of a mutex. A mutex helps us ensure that our program runs correctly by protecting some shared state from being modified by two threads at the same time.<br /><br />Condition&nbsp;Variables&nbsp;solve a problem that often pops up shortly after we make a part of our program thread safe: What do we do when a thread encounters a shared state which it can't do any work on.<br /><br />As an example consider a producer and a consumer thread passing integers across a stack. We have a mutex on the stack to ensure that the producer doesn't try and add items to the stack while the consumer is removing them and vice-versa. But what happens if the consumer acquires the mutex and finds that the stack is empty?<br /><br />A really dumb method would be to unlock the mutex and then immediately try again. This has the downside of it eats up heaps of CPU time while we keep locking-checking-unlocking over and over again. A better option is to sleep for a little bit of time if we find that the stack is empty, but then the question is how long should we wait for?<br /><br />Condition Variables solves this problem by allowing a thread to sleep on the condition variable until another thread wakes it up by&nbsp;signalling&nbsp;that condition variable.<br /><br /><br /><span style="font-size: large;">Sample Code</span><br /><br /><a href="http://bazaar.launchpad.net/~dcoles/+junk/condition-example/view/head:/src/condition_example.c">This sample</a> is a fairly extensive walk through of using condition&nbsp;variables to implement a blocking stack in C.<br /><br />You can <a href="https://code.launchpad.net/~dcoles/+junk/condition-example">download the full project source here</a>.<br /><br /><br /><span style="font-size: large;">Notes about POSIX Thread implementation</span><br /><br /><b>Use a while loop for checking state</b><br />This serves two purposes. On some platforms threads may be spuriously woken up even if the condition&nbsp;variable&nbsp;wasn't signaled. A while loop means we'll go back to waiting.<br /><br /><span style="font-family: 'Courier New', Courier, monospace;">pthread_mutex_lock(&amp;mutex);</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;">while (!correct_state) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; pthread_cond_wait(&amp;cond, &amp;mutex);</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;">// Do some work here...</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;">pthread_mutex_unlock(&amp;mutex);</span><br /><br />A second use is that sometimes it's easier to write code where we signal a condition&nbsp;variable for a more general condition than we're interested in. A thread can wake up and check the exact state and if it's not correct, go back to waiting.<br /><br /><b>Signal vs. Broadcast</b><br />The POSIX Thread API has two different methods for signalling a condition variable: <i><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_broadcast.html">pthread_cond_signal</a></i>&nbsp;and <i><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_broadcast.html">pthread_cond_broadcast</a></i>. The difference is <i>pthread_cond_signal</i>&nbsp;will wake <i>at least</i>&nbsp;one thread, while <i>pthread_cond_broadcast</i>&nbsp;will wake all threads waiting on a condition&nbsp;variable.<br /><br />If each thread checks the state with a while loop like above, <i>pthread_cond_broadcast</i>&nbsp;will always be safe (threads that can't do any work will go back to sleep). The advantage of <i>pthread_cond_signal</i>&nbsp;is if you know only one thread will be able to do work, this won't wake all of the thread (usually it will only wake one, but don't rely on this - again, use a while loop to check state).<br /><br /><b>Timed wait</b><br />If you don't want a thread waiting forever you can use <i><a href="http://pthread_cond_timedwait/">pthread_cond_timedwait</a></i>&nbsp;to try waiting for a condition up to a certain time (specified by absolute <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html">timespec</a> such as one returned by <i><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html">clock_gettime</a></i>). The function will return&nbsp;ETIMEDOUT if/when the absolute time has been passed.<br /><br /><b>Dynamic initialization</b><br />Like mutexs the easiest way to use the static initializer, but in some cases you may need to dynamically allocate a condition&nbsp;variable.<br /><br /><span style="font-family: 'Courier New', Courier, monospace;">// Static</span><br /><span style="font-family: 'Courier New', Courier, monospace;">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;">// Dynamic</span><br /><span style="font-family: 'Courier New', Courier, monospace;">pthread_cond_t cond;</span><br /><span style="font-family: 'Courier New', Courier, monospace;">pthread_cond_init(&amp;cond, NULL);</span><br /><span style="font-family: 'Courier New', Courier, monospace;">// ...</span><br /><span style="font-family: 'Courier New', Courier, monospace;">pthread_cond_destroy(&amp;cond);</span><br /><br /><br /><span style="font-size: large;">Windows</span><br /><br /><div>Newer versions of Windows (Vista and above) have support for <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682052(v=vs.85).aspx">condition variables</a>, though most Windows developers are more familiar with&nbsp;<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682655(v=vs.85).aspx">events</a>. Events are similar to condition&nbsp;variables, but they're not associated with a mutex. You can think of them like a mutex/condition&nbsp;variable&nbsp;pair wrapped around a boolean (it's pretty easy to implement events with condition&nbsp;variables&nbsp;this way).</div><div><br /></div><div>It's possible to implement condition&nbsp;variables&nbsp;with events, but <a href="http://poco.svn.sourceforge.net/viewvc/poco/poco/trunk/Foundation/include/Poco/Condition.h?revision=1742&amp;view=markup">it's not trivial</a>.</div><div><br /></div><div><br /></div><div><span style="font-size: large;">References</span></div><div><ul><li><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09">POSIX Thread API (POSIX.1-2008/SUSv4)</a></li><li><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686364(v=vs.85).aspx">Windows&nbsp;Synchronization&nbsp;Objects</a></li><li><a href="http://man7.org/tlpi/">The Linux Programming Interface</a>&nbsp;- Has an excellent coverage of threads. Also see these two code examples: <a href="http://man7.org/tlpi/code/online/dist/threads/prod_no_condvar.c.html">prod_no_condvar.c</a> and <a href="http://man7.org/tlpi/code/online/dist/threads/prod_condvar.c.html">threads/prod_condvar.c</a>.</li></ul></div>