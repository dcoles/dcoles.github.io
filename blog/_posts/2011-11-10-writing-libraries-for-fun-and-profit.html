---
layout: post
title: Writing libraries for fun and profit
date: '2011-11-10T20:52:00.001-08:00'
author: David Coles
tags:
- Programming
- C++
- C
- Libraries
modified_time: '2011-11-10T22:55:33.146-08:00'
blogger_id: tag:blogger.com,1999:blog-4144304653010663466.post-4286896701887902824
blogger_orig_url: https://blog.dcoles.net/2011/11/writing-libraries-for-fun-and-profit.html
redirect_from:
  - /blog/2011/11/writing-libraries-for-fun-and-profit.html
---

A post by <a href="http://0pointer.de/blog/projects/libabc.html">Lennart Poettering on Linux software library design</a> sparked a parallel discussion on Google+ about library design. Despite being intended for Kernel developers venturing into userspace, <a href="https://git.kernel.org/?p=linux/kernel/git/kay/libabc.git">libabc</a> contains some <a href="https://git.kernel.org/?p=linux/kernel/git/kay/libabc.git;a=blob_plain;f=README">excellent tips for C library design</a> and is would be a great template for writing a library of your own.<br /><br />Here's some additional points brought up during the side-discussion:<br /><br /><b>Autotools</b><br />While <a href="http://en.wikipedia.org/wiki/GNU_build_system">Autotools</a> is by far the most widely used build configuration system for Unix, it suffers from being a rather archaic system of shell scrips and is extremely unfriendly to non-Unix systems. <a href="http://www.cmake.org/">CMake </a>offers an interesting alternative with a support for build configuration, project generation and cross-compilation. Project generation isn't perfect (it's going to look weird compared to native Visual Studio project), but it's a great step forward in getting your library to run on multiple platforms.<br /><br /><b>Calling exit(), abort() and using assert() inside a library</b><br />There's quite a deal of contention on this topic. Everyone seems to agree that calling exit() inside a libray is a really bad idea. Using abort() and assert() seem to be more up in the air. It's possible to use abort as a rather crude exception system (via an evil combination of a SIGABRT signal handler and longjump), but in general it's a bad idea. On POSIX systems, signals don't play very well with threads and you completely mess up the standard function-stack flow of your program (<a href="http://stackoverflow.com/questions/1376085/c-safe-to-use-longjmp-and-setjmp">this is especially bad for C++</a>). Thus a SIGABRT is almost always fatal. An argument for using abort() is flagging unexpected behavior - things that shouldn't ever happen unless there is a serious going-to-crash-your-code-150-lines-later kind of bug. What do you do when malloc fails? Let your code run wild until it crashes or crash it right at the source of the problem. On the other hand, try explaining this to your manager why the whole application stack crashed because of a minor issue. Asserts offer a kind of middle ground that only blows up when debugging.<br /><br /><b>Avoid callbacks in your API/Use iterators</b><br />This confused me a little bit at first until I realised that this applied to using callbacks for accessing the contents of a collection or abstract data type rather than being against the concept of callbacks in general. <a href="http://pine.cs.yale.edu/pinewiki/C/Iterators">Here's an example of how both styles of interface can be implemented</a>. Callbacks can still be very handy for handling asynchronous events.<br /><br /><b>C++ is bad for library interfaces</b><br /><div>C++ is a pretty amazing and flexible language. It's also got some really horrible features that can come back and bite you in really horrid ways. There's three main issues with using C++ for writing library interfaces:</div><div><ol><li>Private member&nbsp;variables&nbsp;are part of a classes implementation, completely messing up information hiding. The <a href="http://en.wikipedia.org/wiki/Opaque_pointer">Pimpl Idiom</a> is one very common solution, but does make your classes more convoluted.</li><li><a href="http://en.wikipedia.org/wiki/Name_mangling">Name mangling in C++</a>&nbsp;causes all sorts of problems. And it differs between compilers. Even if using the same compiler, it's possible for two compilation units to generate the same mangled name (think two static libraries) and there's no&nbsp;guarantee&nbsp;that the compiler will event detect this horrible case. And if you want to dynamically load a shared library (using dlopen) you have to use&nbsp;<a href="http://www.faqs.org/docs/Linux-mini/C++-dlopen.html">`extern C`&nbsp;to expose an unmangled C-style interface to your library</a> anyway (though you can use a factory/interface pattern to still expose C++ classes).</li><li>Versioning and ABI stability. Due to both of the points above, it's harder to maintain ABI compatibility of C++ interfaces. C++ is rather&nbsp;notorious for the&nbsp;<a href="http://en.wikipedia.org/wiki/Fragile_binary_interface_problem">Fragile binary interface problem</a>.&nbsp;Adding and changing private member&nbsp;variables&nbsp;will break the ABI even if you haven't broken API&nbsp;compatibility. There's also the issue that symbol hiding in <a href="http://gcc.gnu.org/wiki/Visibility">C++ is much-much harder than C</a>&nbsp;(you can't just making your functions static).</li></ol><div><br /></div><div>Good library design is a real art. I think one of my favourite points I've read over the years is that <a href="http://ozlabs.org/~rusty/index.cgi/tech/2008-03-18.html">libraries should be hard to misuse</a>. If you can build an API where it's impossible to misuse, then your APIs will be easier to use and much lower risk of developers getting the wrong mental model for your library.&nbsp;</div><div><br /></div><div><br /></div><b>Other useful links (in no particular order)</b></div><div><ul><li><a href="http://www.akkadia.org/drepper/dsohowto.pdf">Ulrich Drepper: Dynamically-loaded Shared Objects (DSOs)</a></li><li><a href="http://rusty.ozlabs.org/?p=140">Rusty Russel on C Library Implementation</a></li><li><a href="http://ozlabs.org/~rusty/index.cgi/tech/2008-03-30.html">Rusty Russel's "Hard to Misuse" score list</a></li><li><a href="http://mirror.linux.org.au/pub/linux.conf.au/2008/slides/137-api_design_lca2008.pdf">Erik de Castro Lopo Designing Library APIs (Slides from Linux.conf.au 2008 Talk)</a></li><li><a href="http://davidz25.blogspot.com/2011/07/writing-c-library-intro-conclusion-and.html">David Zeuthen: Writing a C Library (series)</a></li></ul></div><div><br /></div>
