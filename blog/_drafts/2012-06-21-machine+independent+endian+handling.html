---
layout: post
title: Machine independent endian handling
date: '2012-06-21T00:06:00.000-07:00'
author: David Coles
tags: 
modified_time: '2012-06-21T00:06:02.724-07:00'
blogger_id: tag:blogger.com,1999:blog-4144304653010663466.post-4499522532953174365
---

If you're writing any code with networking, you'll eventually run into the problem of how you send binary data from one device to another. While text based protocols are relatively straight forward to use and don't suffer from endian issues, they're significantly less&nbsp;efficient&nbsp;than an equivalent binary representation.<br /><br />One of the interesting properties of C-based languages is that you can easily access the underlying binary representation of everything from basic types (int, double, float) to structures and classes. In this case it's often very tempting just to do something like this:<br /><br /><span style="font-family: 'Courier New', Courier, monospace;">struct Purchase</span><br /><span style="font-family: 'Courier New', Courier, monospace;">{<br />&nbsp; &nbsp; char item_name[10];</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; float item_cost;</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; int quantity;</span><br /><span style="font-family: 'Courier New', Courier, monospace;">};</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;">struct Purchase p = {"Apple", 0.60f, 7};</span><br /><span style="font-family: 'Courier New', Courier, monospace;">send(sockfd, &amp;p, sizeof(p), 0x0);</span><br /><br />Now there's a few problems with this here. First off that int may not actually be 4-bytes - on some platforms sizeof(int) may be 4. A good solution here is to use <stdint.h> types such as int32_t to&nbsp;specify&nbsp;an exact size.&nbsp;</stdint.h><br /><br />A second problem is that the compiler may insert padding between fields to ensure that they align on some hardware&nbsp;dependent boundary (floats and doubles are usually the main culprits here).&nbsp;For example, on my computer the offset of item_cost is 12-bytes rather than the 10 you might expect.<br /><br />One possible solution it to use #pragma pack or __attribute__((packed)) to force the compiler to pack data with 1-byte alignment, but this isn't&nbsp;guaranteed&nbsp;to work on all&nbsp;platforms (on x86 it works, although field access is slower; on ARM the hardware will often cause a SIGBUS to be thrown). A better idea is to just individually&nbsp;serialize&nbsp;each field rather than trying to do the whole struct at once.<br /><br /><span style="font-family: 'Courier New', Courier, monospace;">// Serialize purchase struct</span><br /><span style="font-family: 'Courier New', Courier, monospace;">send(sockfd, p.item_name, sizeof(p.item_name), 0x0);</span><br /><span style="font-family: 'Courier New', Courier, monospace;">send(sockfd, &amp;p.item_cost, sizeof(p.item_cost), 0x0);</span><br /><span style="font-family: 'Courier New', Courier, monospace;">send(sockfd, &amp;p.quantity, sizeof(p.quantity), 0x0);</span><br /><br /><br />