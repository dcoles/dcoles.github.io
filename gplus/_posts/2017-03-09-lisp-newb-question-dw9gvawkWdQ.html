---
title: "G+: Lisp newb question"
date: "2017-03-09 11:40:14-0500"
modified_time: "2017-03-09 11:40:14-0500"
layout: post
gplus_orig_url: https://plus.google.com/+DavidColes/posts/dw9gvawkWdQ
---

<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBMYQroHG03cfOJQ-Lu30rOA8T35GOl9fQUFQwpVeU=s64-c" style="border-radius: 50%"><strong><span class="author">David Coles</span></strong> <time datetime="2017-03-09T11:40:14-05:00" title="2017-03-09 11:40:14-05:00">09 Mar 2017</time></header>
<div class="content">Lisp newb question. Is the following legal?<br><br>((lambda (f) (f &#39;(b c))) &#39;(lambda (x) (cons &#39;a x)))<br><br>I&#39;ve been following along with Paul Graham&#39;s excellent &quot;The Roots of Lisp&quot; in my second attempt at writing an interpreter (<span class="proflinkWrapper"><span class="proflinkPrefix">+</span><a class="proflink bidi_isolate" href="https://plus.google.com/108688191891412975833" oid="108688191891412975833" >Matt Giuca</a></span> will remember the 10ft hole I dug myself in last time). This time everything works, except this expression explodes on me.<br><br>I suspect it&#39;s a typo. Common Lisp chokes on this kind of expression, but Scheme is fine so long as the second lambda isn&#39;t quoted.<br><br><a rel="nofollow" class="ot-hashtag bidi_isolate" href="https://plus.google.com/s/%23lisp/posts" >#lisp</a> <a rel="nofollow" class="ot-hashtag bidi_isolate" href="https://plus.google.com/s/%23programming/posts" >#programming</a><br></div><hr>
<a href="http://www.paulgraham.com/rootsoflisp.html">
<h2>The Roots of Lisp</h2>
</a>
</article>
<hr>
<div class="plusOnes" style="text-align: right"><strong>(+1's)</strong> 1</div><article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBJAad8DjbntuW4RZOeco9N0CfBzRPxufav3Q19Zw8=s64-c" style="border-radius: 50%"><strong><span class="author">Matt Giuca</span></strong> <time datetime="2017-03-09T21:17:38-05:00" title="2017-03-09 21:17:38-05:00">09 Mar 2017</time></header>
<div class="content">/me digs up 10-year-old Lisp knowledge.<br><br>TL;DR: It&#39;s not a typo. It&#39;s correct but confusing, and I think it exposes a design flaw in this Lisp dialect. (And note that this is specific to this particular and quite hypothetical Lisp dialect, not mainstream Lisps like CL and Scheme.)<br><br>My initial intuition was that it&#39;s a typo too. Surely the expression (lambda ...) creates a function object which would then be passed as an argument to the left-hand function, much like you would express in Python:<br><br>(lambda f: f([&#39;b&#39;, &#39;c&#39;]))(lambda x: [&#39;a&#39;] + x)<br><br>Surely quoting the right-hand lambda would create not a function object, but a literal list expression <b>describing</b> the lambda, which wouldn&#39;t work at all...<br><br>But no, something very strange is going on here (now the details are coming back to me).<br><br>&quot;Real&quot; Lisps (CL and Scheme) probably behave more like Python, with lambdas producing actual functors, but this &quot;little Lisp&quot; (much closer to McCarthy&#39;s original Lisp, but not identical) is much simpler and more primitive and its lambdas behave differently.<br><br>This little Lisp doesn&#39;t actually <b>have</b> function objects as a first-class type. The <b>only</b> values in the execution environment are atoms and s-expressions (pairs). &quot;lambda&quot; is not actually a function (if you directly eval a lambda expression, you get a &quot;no such variable: lambda&quot; error). Lambda is a special form which only exists as a literal list.<br><br>So if you evaluate this expression in Graham&#39;s Lisp -- note the right lambda is unquoted:<br>((lambda (f) (f &#39;(b c))) (lambda (x) (cons &#39;a x)))<br><br>You should get &quot;no such variable: lambda&quot;, because it will be recursively trying to evaluate the expression (lambda (x) (cons &#39;a x)), a call to the &quot;lambda&quot; function, which doesn&#39;t exist.<br><br>By quoting that expression on the right, you are passing the literal list object (lambda (x) (cons &#39;a x)) as the parameter f. So during the execution of the left lambda, the environment dictionary should include {&#39;f&#39;: (lambda (x) (cons &#39;a x))}. Now when we go to evaluate the expression (f &#39;(b c)), we look up f in the dictionary and replace it with ((lambda (x) (cons &#39;a x)) &#39;(b c)), and then finally we apply that lambda: (cons &#39;a &#39;(b c)).<br><br>The real WTF here (the reason it&#39;s so confusing) is that Graham&#39;s Lisp <b>special-cases</b> bare unquoted lambdas on the left of a function call expression! If we ask ourselves, in a function call expression (f x), does f get interpreted literally, or does it get evaluated? The answer depends on whether f is a lambda.<br><br>In the expression (f x), where f is an atom, we evaluate both f and x; looking up f in the dictionary to get its &quot;function object&quot; (actually just a lambda expression), and then applying it. But in the expression ((lambda ...) x), we <b>do not</b> evaluate the left hand side; we just treat it as a lambda. That&#39;s why you don&#39;t have to quote a literal lambda on the left side of a function application. Why in this example, the left lambda is unquoted but the right lambda is quoted. I&#39;m not sure if this was a problem with McCarthy&#39;s Lisp or something introduced here by Graham.<br><br>I would suggest a semantic change to make this language more palatable: always evaluate the LHS of an application expression, which means you need to quote <b>both</b> lambdas:<br><br>(&#39;(lambda (f) (f &#39;(b c))) &#39;(lambda (x) (cons &#39;a x)))<br><br>As an exercise to the reader, figure out how you would update the &quot;eval&quot; function in Section 4 to follow these new semantics (I think it actually simplifies things because you remove one special case, but I haven&#39;t tried it).</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBJAad8DjbntuW4RZOeco9N0CfBzRPxufav3Q19Zw8=s64-c" style="border-radius: 50%"><strong><span class="author">Matt Giuca</span></strong> <time datetime="2017-03-09T23:28:41-05:00" title="2017-03-09 23:28:41-05:00">09 Mar 2017</time></header>
<div class="content">Confirmed that McCarthy&#39;s original Lisp (described in <i>Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I</i>, 1960) has the exact same semantics.<br><br>To further highlight the problem here, consider the expression:<br>((f x) y)<br><br>If f is a curried function that returns a function... this doesn&#39;t actually work because this Lisp only accepts two special cases of function application:<br><br>(f x) where f is an atom, or<br>((lambda (...) (...)) x)<br><br>You cannot put any arbitrary expression on the LHS of an application, even if that expression returns a function. You must first assign the result of the expression into a variable, then put that variable on the LHS of the application. Not composable.</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBMYQroHG03cfOJQ-Lu30rOA8T35GOl9fQUFQwpVeU=s64-c" style="border-radius: 50%"><strong><span class="author">David Coles</span></strong> <time datetime="2017-03-10T02:59:11-05:00" title="2017-03-10 02:59:11-05:00">10 Mar 2017</time></header>
<div class="content">Thanks for that terrific explanation. I think since I&#39;d been so far down the path of implementing the built-in operators with Python functions that it didn&#39;t even occur to me that eval returning something other than an Atom or a List was verboten.<br><br>I still think it&#39;s useful in showing that it&#39;s possible to do computation without invoking a new type, but as you&#39;ve pointed out it makes the syntax a bit hairy.<br><br>Honestly I think I&#39;m more bothered by the operators `cond` and `quote` (the equivalent of statements in Python) not being functions. However I can see that without them you wouldn&#39;t have much of a language and if they were part of the lexical syntax then  you&#39;d lose the beauty code and data being interchangeable as lists.</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBJAad8DjbntuW4RZOeco9N0CfBzRPxufav3Q19Zw8=s64-c" style="border-radius: 50%"><strong><span class="author">Matt Giuca</span></strong> <time datetime="2017-03-10T03:42:12-05:00" title="2017-03-10 03:42:12-05:00">10 Mar 2017</time></header>
<div class="content">The interesting part of the exercise (for me) is the &quot;eval&quot; implementation, written there in Lisp, which shows you the precise semantics of the language, implemented in itself.<br><br>The exercise, for me, was essentially porting the &quot;eval&quot; function (and the supporting functions) from Lisp into Python and therefore having a precisely equivalent Lisp interpreter written in Python. That way, you don&#39;t get tempted to bring your own intuition about what &quot;lambda&quot; should do, for instance. You just port exactly what&#39;s written and then realise what you&#39;ve created after the fact.<br><br>Yes I see what you mean about those primitives feeling a bit broken in that they do things that an ordinary function can&#39;t do (i.e., they care about the lexical form of their arguments where no other function can do that). &quot;atom&quot; is the same; (atom x) gives a different result to (atom (f y)), even if (f y) returns the same value as x. But if it helps, a) those things are special because they have to be; they are essentially the syntax of the language, and b) more advanced Lisps let you write your own macros that also care about the lexical structure of their arguments (essentially functions that automatically quote their arguments).</div></article>
<hr>
