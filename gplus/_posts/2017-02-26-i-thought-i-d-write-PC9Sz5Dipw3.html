---
title: "G+: I thought I'd write an update on git \u2026"
date: "2017-02-26 12:27:26-0500"
modified_time: "2017-02-26 12:27:26-0500"
layout: post
gplus_orig_url: https://plus.google.com/+DavidColes/posts/PC9Sz5Dipw3
---

<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBMYQroHG03cfOJQ-Lu30rOA8T35GOl9fQUFQwpVeU=s64-c" style="border-radius: 50%"><strong><span class="author">David Coles</span></strong> <time datetime="2017-02-26T12:27:26-05:00" title="2017-02-26 12:27:26-05:00">26 Feb 2017</time></header>
<blockquote cite="https://plus.google.com/+LinusTorvalds/posts/7tp2gYWQugL">
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mCW0o3LDiXyDQjykn4tzbYoOIe1jFjENEiPT_S1AFw=s64-c" style="border-radius: 50%"><strong><span class="author">Linus Torvalds</span></strong></header>
<div class="content">I thought I&#39;d write an update on git and SHA1, since the SHA1 collision attack was so prominently in the news. <br><br>Quick overview first, with more in-depth explanation below:<br><br><b>(1)</b> First off - the sky isn&#39;t falling. There&#39;s a big difference between using a cryptographic hash for things like security signing, and using one for generating a &quot;content identifier&quot; for a content-addressable system like git.<br><br><b>(2)</b> Secondly, the nature of this particular SHA1 attack means that it&#39;s actually pretty easy to mitigate against, and there&#39;s already been two sets of patches posted for that mitigation.<br><br><b>(3)</b> And finally, there&#39;s actually a reasonably straightforward transition to some other hash that won&#39;t break the world - or even old git repositories.<br><br>Anyway, that&#39;s the high-level overview, you can stop there unless you are interested in some more details (keyword: &quot;some&quot;. If you want more, you should participate in the git mailing list discussions - I&#39;m posting this for the casual git users that might just want to see some random comments).<br><br>Anyway, on to the &quot;details&quot;:<br><br>(1) What&#39;s the difference between using a hash for security vs using a hash for object identifiers in source control management?<br><br>Both want to use cryptographic hashes, but they want to use them for different reasons.<br><br>A hash that is used for security is basically a statement of trust: and if you can fool somebody, you can make them trust you when they really shouldn&#39;t. The point of a cryptographic hash there is to basically <b>be</b> the source of trust, so in many ways the hash is supposed to fundamentally protect against people you cannot trust other ways. When such a hash is broken, the whole point of the hash basically goes away.<br><br>In contrast, in a project like git, the hash isn&#39;t used for &quot;trust&quot;. I don&#39;t pull on peoples trees because they have a hash of a4d442663580. Our trust is in people, and then we end up having lots of technology measures in place to secure the actual data. <br><br>The reason for using a cryptographic hash in a project like git is because it pretty much guarantees that there is no accidental clashes, and it&#39;s also a really really good error detection thing. Think of it like &quot;parity on steroids&quot;: it&#39;s not able to correct for errors, but it&#39;s really really good at detecting corrupt data.<br><br>Other SCM&#39;s have used things like CRC&#39;s for error detection, although honestly the most common error handling method in most SCM&#39;s tends to be &quot;tough luck, maybe your data is there, maybe it isn&#39;t, I don&#39;t care&quot;.<br><br>So in git, the hash is used for de-duplication and error detection, and the &quot;cryptographic&quot; nature is mainly because a cryptographic hash is really good at those things.<br><br>I say &quot;mainly&quot;, because yes, in git we also end up using the SHA1 when we use &quot;real&quot; cryptography for signing the resulting trees, so the hash does end up being part of a certain chain of trust. So we do take advantage of some of the actual security features of a good cryptographic hash, and so breaking SHA1 does have real downsides for us.<br><br>Which gets us to ...<br><br>(2) Why is this particular attack fairly easy to mitigate against at least within the context of using SHA1 in git?<br><br>There&#39;s two parts to this one: one is simply that the attack is not a pre-image attack, but an identical-prefix collision attach. That, in turn, has two big effects on mitigation:<br><br> (a) the attacker can&#39;t just generate any random collision, but needs to be able to control and generate both the &quot;good&quot; (not really) and the &quot;bad&quot; object.<br><br> (b) you can actually detect the signs of the attack in both sides of the collision.<br><br>In particular, (a) means that it&#39;s really hard to hide the attack in data that is transparent. What do I mean by &quot;transparent&quot;? I mean that you actually see and react to all of the data, rather than having some &quot;blob&quot; of data that acts like a black box, and you only see the end results.<br><br>In the pdf examples, the pdf format acted as the &quot;black box&quot;, and what you see is the printout which has only a very indirect relationship to the pdf encoding.<br><br>But if you use git for source control like in the kernel, the stuff you really care about is <b>source</b> <b>code</b>, which is very much a transparent medium. If somebody inserts random odd generated crud in the middle of your source code, you will absolutely notice. <br><br>Similarly, the git internal data structures are actually very transparent too, even if most users might not consider them so. There are places you could try to hide things in (in particular, things like commits that have a NUL character that ends printout in &quot;git log&quot;), but &quot;git fsck&quot; already warns about those kinds of shenanigans.<br><br>So fundamentally, if the data you primarily care about is that kind of transparent source code, the attack is pretty limited to begin with. You&#39;ll <b>see</b> the attack. It&#39;s not silently switching your data under from you.<br><br>&quot;But I track pdf files in git, and I might not notice them being replaced under me?&quot;<br><br>That&#39;s a very valid concern, and you&#39;d want your SCM to help you even with that kind of opaque data where you might not see how people are doing odd things to it behind your back. Which is why the second part of mitigation is that (b): it&#39;s fairly trivial to detect the fingerprints of using this attack.<br><br>So we already have patches on the git mailing list which will detect when somebody has used this attack to bring down the cost of generating SHA1 collisions. They haven&#39;t been merged yet, but the good thing about those mitigation measures is that not everybody needs to even run them: if you host your project on something like <a rel="nofollow" target="_blank" href="http://github.com" class="ot-anchor bidi_isolate" jslog="10929; track:click" dir="ltr">http://github.com</a> or <a rel="nofollow" target="_blank" href="http://kernel.org" class="ot-anchor bidi_isolate" jslog="10929; track:click" dir="ltr">kernel.org</a>, it&#39;s already sufficient if the hosting place runs the checks every once in a while - you&#39;ll get notified if somebody poisoned your well.<br><br>And finally, the &quot;yes, git will eventually transition away from SHA1&quot;. There&#39;s a plan, it doesn&#39;t look all that nasty, and you don&#39;t even have to convert your repository. There&#39;s a lot of details to this, and it will take time, but because of the issues above, it&#39;s not like this is a critical &quot;it has to happen <i>now</i> thing&quot;.</div></article>
<hr>
</blockquote>
</article>
<hr>
<div class="plusOnes" style="text-align: right"><strong>(+1's)</strong> 1</div><article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBJAad8DjbntuW4RZOeco9N0CfBzRPxufav3Q19Zw8=s64-c" style="border-radius: 50%"><strong><span class="author">Matt Giuca</span></strong> <time datetime="2017-02-26T18:38:37-05:00" title="2017-02-26 18:38:37-05:00">26 Feb 2017</time></header>
<div class="content">I disagree about (1)... git users <b>do</b> rely on the SHA-1 hash for trust. There&#39;s an implicit understanding (built into the system) that I can download git objects from any source into my local repository, and that is a safe, order-independent and side-effect-free operation. The only thing I have to manually verify is that my HEAD hash matches a trusted upstream, and I&#39;m good. A SHA-1 collision breaks that assumption.<br><br>Sure, it&#39;s tricky to exploit. And if I&#39;m only pulling from a single trusted source over HTTPS or SSH, then I&#39;m fine. But consider this:<br><br>1. A malicious user forks a good repository.<br>2. The malicious user inserts a backdoor into the code (must be in a file that was changed recently). They use a SHA-1 collision to give the backdoored file the exact same SHA-1 hash as the original version. Because git is built on a hash chain, the tree containing the blob, the commit that introduced that change, and all child commits, will all happily refer to the modified blob without needing to be modified themselves.<br>3. The malicious user makes a few dummy commits which are an innocuous minor patch.<br>4. The malicious user uploads their modified repo to GitHub or another git hosting provider.<br>5. They then have to trick me into downloading their bad blob <b>before</b> I download the good blob from upstream. They might tell me they have a patch they want me to look at, so I pull their repo (I haven&#39;t pulled from origin/master in a few days). By pulling their repo, I download the bad blob onto my machine. Because I don&#39;t trust him, I don&#39;t compile or execute the code, I just look at the changes (and note that the bad blob isn&#39;t visible to me because it&#39;s not in the commits he added onto HEAD, it&#39;s hidden in the earlier commits).<br>6. Later, I pull from origin/master (the &quot;good&quot; upstream), and check out master. Now I&#39;m no longer in the malicious guy&#39;s branch and have no expectation of caution, so I build and run the code.<br><br>The fatal flaw is that Step 6 <b>did not</b> download the good blob from upstream, because git sees that I already have its hash in my local repo. So when I check out master, git is telling me that I&#39;m at the same hash as what everyone else is at; what GitHub web pages says is the hash for origin/master. But my code is actually different to what everyone else has, and it will remain that way until the file changes upstream. A &quot;git diff&quot; between my master and the malicious guy&#39;s branch won&#39;t show these changes. The only way to detect this would be to look at the diff for every single commit and compare it to what GitHub is showing.<br><br>I don&#39;t think signing helps, because as Linus points out, you only sign the commit object; it still relies on the hash chain&#39;s integrity.<br><br>Basically this attack is a bit tricky to pull off because it relies on the downstream users downloading the malicious blobs before they download the good upstream blobs. But totally feasible.<br><br>(And I don&#39;t know enough about this to say whether (2) is a mitigation...)</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBMYQroHG03cfOJQ-Lu30rOA8T35GOl9fQUFQwpVeU=s64-c" style="border-radius: 50%"><strong><span class="author">David Coles</span></strong> <time datetime="2017-02-26T18:55:01-05:00" title="2017-02-26 18:55:01-05:00">26 Feb 2017</time></header>
<div class="content">I believe one tricky aspect of the ordeal is that you need control of both the &quot;good&quot; and &quot;evil&quot; versions for this particular attack on SHA1 (really they&#39;re both evil twins, one just acts innocent).<br><br>However I&#39;d be extremely hesitant to just brush this off. Most security disasters aren&#39;t due to a giant &quot;give me root&quot; kind of screw up. Usually they&#39;re a collection of apparently innocent looking bugs that taken together can let a malicious attacker do something horrible.</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBJAad8DjbntuW4RZOeco9N0CfBzRPxufav3Q19Zw8=s64-c" style="border-radius: 50%"><strong><span class="author">Matt Giuca</span></strong> <time datetime="2017-02-26T22:15:46-05:00" title="2017-02-26 22:15:46-05:00">26 Feb 2017</time></header>
<div class="content">You don&#39;t need to control good and evil versions. In my scenario, the &quot;good&quot; version is a legitimate blob from an upstream repo. You just need to get someone to download your evil version <b>first</b>.<br><br>Anyway, I tried out this attack (using the shattered PDF files) and I was thwarted by one thing ... git blob hashes aren&#39;t <b>pure</b> SHA-1 hashes of the file: it prepends the word &quot;blob&quot; and the file size to the front, then hashes. That causes the resultant SHA-1 hash to diverge and I don&#39;t think there&#39;s a trivial way to engineer a collision for these files. BUT that doesn&#39;t stop an attacker from using the same technique to create two files whose git blob hash (as opposed to the bare file hash) matches.</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBMYQroHG03cfOJQ-Lu30rOA8T35GOl9fQUFQwpVeU=s64-c" style="border-radius: 50%"><strong><span class="author">David Coles</span></strong> <time datetime="2017-02-27T00:59:23-05:00" title="2017-02-27 00:59:23-05:00">27 Feb 2017</time></header>
<div class="content">The problem with the SHAttered attack is that it creates a pair of documents with common prefixes P and suffixes S. The only difference is in the 2 pairs of &#39;near-collision&#39; blocks [(M_11, M_12), (M_21, M_22)], paired such that after the blocks the documents still have the same hash:<br><br>SHA-1(P ∣∣ M_11 ∣∣ M_12 || S) = SHA-1(P ∣∣ M_21 ∣∣ M_22 ∣∣ S)<br><br>Thus to mount an attack, the malicious user would have to be the one to create both the &quot;good&quot; and &quot;bad&quot; blob (because only the malicious user could generate the two pairs of blocks). That makes an attack distinctly harder than being able to generate a collision against any existing document.<br><br>Though I do agree with you that while git might be immune to a file content collision, there&#39;s nothing stopping someone generating a blob SHA-1 collision. (While your attack had identical prefixes due to the documents having the same size, I believe the values of the near-collision pairs are dependent on the value of the prefix chosen due to chaining).<br><br>I wonder if we need to start salting content hashes with something like a first-seen timestamp or HEAD commit-ID. Downside to that would be it would break a bunch of nice properties like content deduplication.</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBJAad8DjbntuW4RZOeco9N0CfBzRPxufav3Q19Zw8=s64-c" style="border-radius: 50%"><strong><span class="author">Matt Giuca</span></strong> <time datetime="2017-02-27T18:40:55-05:00" title="2017-02-27 18:40:55-05:00">27 Feb 2017</time></header>
<div class="content">Ah OK. That makes it harder but still plausible: the bad guy just needs to author a pair of files: one with a legit minor change to an existing file, and one with a backdoor. Have the legit minor change accepted upstream, then do the above attack.<br><br>Do you think it&#39;s possible for <b>one</b> of the colliding files to have totally human-crafted content (while the other one presumably has some garbage that&#39;s just there to make the maths work out)? Or do both files need to have random garbage? If so I would acquiesce that the attack is infeasible because you would have to convince the maintainer to accept a &quot;good&quot; patch with garbage bytes in it.</div></article>
<hr>
<article>
<header>
<img src="https://lh3.googleusercontent.com/a-/AAuE7mBMYQroHG03cfOJQ-Lu30rOA8T35GOl9fQUFQwpVeU=s64-c" style="border-radius: 50%"><strong><span class="author">David Coles</span></strong> <time datetime="2017-03-01T11:22:27-05:00" title="2017-03-01 11:22:27-05:00">01 Mar 2017</time></header>
<div class="content">Using this attack to generate documents in a transparent format like source code or text documents would be pretty difficult. You need to insert 2 x 512 bits (2 x 64-bytes) of binary data into your document without anyone noticing (in the attack&#39;s PDF&#39;s they put it in the JPEG header and used some, as of yet, undisclosed tricks in the JPEG format to make the documents look visually distinct).<br><br>Ignoring the difficulty of hiding binary blocks in a text file (the attack might still be possible using a reduced character set), you still don&#39;t have a lot of flexibility is crafting documents. They still need to be almost identical (common prefix P and suffix S) and I&#39;m pretty sure that pre-selecting (M_11, M_12) would make the search for (M_21, M_22) computationally much harder (the birthday paradox doesn&#39;t &quot;work&quot; if you pre-pick one of the candidates).<br><br>Thus you would need to hide a backdoor in both documents (in which case why bother with using a collision) or in the two near collisions blocks (which were already hard to find any candidates).<br><br>I also suspect these 2 x 512 bit blocks are pretty easy to detect since the goal of the second block is to &quot;undo&quot; the SHA1 difference between documents caused by the first blocks.</div></article>
<hr>
